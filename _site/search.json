[
  {
    "objectID": "posts/Start With Quarto/index.html",
    "href": "posts/Start With Quarto/index.html",
    "title": "Start With Quarto",
    "section": "",
    "text": "This is a simple tutorial of how we can read in an online dataset and create a simple visualizaion for Palmer Penguins dataset.\n\nData import\nWe need to first load in the dataset from online repository. We can use pandas to do this.\n\nimport pandas as pd\n# retrieve from online repository\nurl = \"https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\nHere we successfully read in the dataset, and then we can start building a simple visualization.\n\n\nPlotting\nWe will be using matplotlib for plotting since it offers us great freedom in customizing the graph.\n\nimport matplotlib.pyplot as plt\n\n# Create a scatterplot to visualize the relationship between Flipper length and culmen Length\nplt.scatter(x = penguins['Flipper Length (mm)'], y = penguins['Culmen Length (mm)'])\n# Add a title to the graph\nplt.title(\"Flipper Length VS Culmen Length\")\n# Name the axises\nplt.xlabel(\"Flipper Length (mm)\")\nplt.ylabel(\"Culmen Length (mm)\")\nplt.show()\n\n\n\n\nThis is a scatter plot based on palmer penguins dataset. It plots the penguins’ flipper length against culmen length. In general, it shows a positive correlation between the two length."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Database Queries and Interactive Visualizations with Python\n\n\n\n\n\n\n\n\n\n\n\n\nOct 22, 2023\n\n\nHaoran Jia\n\n\n\n\n\n\n  \n\n\n\n\nStart With Quarto\n\n\n\n\n\n\n\n\n\n\n\n\nOct 3, 2023\n\n\nHaoran Jia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/Database Queries and Interactive Visualizations with Python/index.html",
    "href": "posts/Database Queries and Interactive Visualizations with Python/index.html",
    "title": "Database Queries and Interactive Visualizations with Python",
    "section": "",
    "text": "Source: https://plotly.com/about-us/\n\n\nIn this tutorial, we’ll work with sqlite3, plotly, and pandas on a climate dataset. By the end, you should be comfortable with creating a SQLite database using Python, querying with SQL, and crafting customized graphs with Plotly.\nNote: For the successful rendering of the interactive plots, run the following.\n\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\n\n\nData Import\nFirst, we need to read in three required tables with pandas, and then we will be creating a database based on these tables.\n\nimport pandas as pd\n\n# Read from files\nstations = pd.read_csv(\"station-metadata.csv\")\ntemps = pd.read_csv('temps_stacked.csv')\ncountries = pd.read_csv('countries.csv')\n\nLet’s take a look at each dataset.\n\nstations.head()\n\n\n\n\n\n\n\n\nID\nLATITUDE\nLONGITUDE\nSTNELEV\nNAME\n\n\n\n\n0\nACW00011604\n57.7667\n11.8667\n18.0\nSAVE\n\n\n1\nAE000041196\n25.3330\n55.5170\n34.0\nSHARJAH_INTER_AIRP\n\n\n2\nAEM00041184\n25.6170\n55.9330\n31.0\nRAS_AL_KHAIMAH_INTE\n\n\n3\nAEM00041194\n25.2550\n55.3640\n10.4\nDUBAI_INTL\n\n\n4\nAEM00041216\n24.4300\n54.4700\n3.0\nABU_DHABI_BATEEN_AIR\n\n\n\n\n\n\n\n\ntemps.head()\n\n\n\n\n\n\n\n\nID\nYear\nMonth\nTemp\n\n\n\n\n0\nACW00011604\n1961\n1\n-0.89\n\n\n1\nACW00011604\n1961\n2\n2.36\n\n\n2\nACW00011604\n1961\n3\n4.72\n\n\n3\nACW00011604\n1961\n4\n7.73\n\n\n4\nACW00011604\n1961\n5\n11.28\n\n\n\n\n\n\n\n\ncountries.head()\n\n\n\n\n\n\n\n\nFIPS 10-4\nISO 3166\nName\n\n\n\n\n0\nAF\nAF\nAfghanistan\n\n\n1\nAX\n-\nAkrotiri\n\n\n2\nAL\nAL\nAlbania\n\n\n3\nAG\nDZ\nAlgeria\n\n\n4\nAQ\nAS\nAmerican Samoa\n\n\n\n\n\n\n\nNotice that there is no country names in stations. We may want to add an extra column named country to it for future convenience. We can do this by merging stations and countries using the two-letter ID. As a good practice, all operations with dataframe will be enclosed in a function.\n\ndef prepare_df(stations):\n    \"\"\"\n    Prepare the stations DataFrame by merging it with the countries DataFrame and renaming columns.\n\n    This function extracts the 'FIPS 10-4' code from the 'ID' column of the stations DataFrame,\n    merges the stations DataFrame with the countries DataFrame based on the 'FIPS 10-4' code,\n    drops unnecessary columns, and renames the 'Name' column to 'Country'.\n\n    Parameters:\n    - stations (pd.DataFrame): The stations dataset.\n\n    Returns:\n    - pd.DataFrame: A modified version of the stations DataFrame after merging and renaming operations.\n    \"\"\"\n\n    # Extract the 'FIPS 10-4' code from the 'ID' column\n    stations['FIPS 10-4'] = stations['ID'].str[:2]\n\n    # Merge the stations DataFrame with the countries DataFrame based on the 'FIPS 10-4' code\n    stations = pd.merge(stations, countries, on='FIPS 10-4')\n\n    # Drop unnecessary columns\n    stations = stations.drop(['FIPS 10-4', 'ISO 3166'], axis=1)\n\n    # Rename the 'Name' column to 'Country'\n    stations.rename(columns={'Name': 'Country'}, inplace=True)\n\n    return stations\n\nstations = prepare_df(stations)\n\n\n\nCreating Databases\nIn this section, we are going to create a database with three tables we have: temperatures, stations, and countries.\n\nimport sqlite3\n\n# Create database\nconn = sqlite3.connect(\"temps.db\")\n\nWe observe that temps is extremely large, so we may want to add it to the database by chunks. We can write a function to do this.\n\ndef read_csv_to_database(csv_file_path, database_connection):\n    # Read segmented table into database\n    df_iter = pd.read_csv(csv_file_path, chunksize=100000)\n    for df in df_iter:\n        df.to_sql(\"temperatures\", database_connection, if_exists=\"append\", index=False)\n\ncsv_file_path = 'temps_stacked.csv'\nread_csv_to_database(csv_file_path, conn)\n\nAdd other two datasets to the database.\n\n# Read other two tables into database\nstations.to_sql(\"stations\", conn, if_exists = \"replace\", index = False)\ncountries.to_sql(\"countries\", conn, if_exists = \"replace\", index = False)\n\n279\n\n\nAlways remember to close the dataset connection when you are not using.\n\nconn.close()\n\n\n\nA simple Query Function\nConnect to the database before using, and then create a cursor to interact with it.\n\n# connect to database\nconn = sqlite3.connect(\"temps.db\")\n\nLet’s first check all three tables are in the database.\n\n# Create a cursor object to interact with the SQLite database\ncursor = conn.cursor()\n\n# Execute an SQL query to fetch the names of all tables in the database\ncursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n\n# Print the names of the tables\nprint(cursor.fetchall())\n\n# Close the database connection\nconn.close()\n\n[('temperatures',), ('stations',), ('countries',)]\n\n\nWith the data, we can start to ask our first question: how does the average yearly change in temperature vary within a given country?\nWe may create a map scatter plot where color of dots will represent temperature. But before doing that, we may want to retrieve necessary data frist.\n\nWe are going to do this with a query function called query_climate_database which accepts four arguments:\n\n\ncountry, a string giving the name of a country for which data should be returned.\nyear_begin and year_end, two integers giving the earliest and latest years for which should be returned.\nmonth, an integer giving the month of the year for which should be returned.\n\nThe return value is a Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year.\n\ndef query_climate_database(country, year_begin, year_end, month):\n    \"\"\"\n    Fetch climate data for a specified country, year range, and month from an SQLite database.\n\n    This function queries temperature data based on a specified country, year range, and month\n    from an SQLite database and returns the data as a pandas DataFrame.\n\n    Parameters:\n    - country (str): The name of the country for which data is to be fetched.\n    - year_begin (int): The starting year for the data range.\n    - year_end (int): The ending year for the data range.\n    - month (int): The month for which data is to be fetched.\n\n    Returns:\n    - pd.DataFrame: A DataFrame containing temperature data for the specified country, year range, and month.\n\n    Example:\n    &gt;&gt;&gt; df = query_climate_database('India', 2000, 2020, 1)\n    Fetches temperature data for India for the month of January between the years 2000 and 2020.\n    \"\"\"\n\n    # Connect to the SQLite database\n    conn = sqlite3.connect(\"temps.db\")\n    cursor = conn.cursor()\n\n    # Execute the SQL query to fetch temperature data\n    cursor.execute(f\"SELECT s.NAME, s.LATITUDE, s.LONGITUDE, s.Country, t.Year, t.Month, t.Temp \\\n                     FROM temperatures t JOIN stations s ON s.ID = t.ID \\\n                     WHERE s.Country = '{country}' AND Year &gt;= {year_begin} AND Year &lt;= {year_end} AND t.Month = {month}\")\n\n    # Convert the fetched data to a pandas DataFrame\n    result_df = pd.DataFrame(cursor.fetchall(), columns=['Name', 'Latitude', 'Longitude',\n                                                         'Country', 'Year', 'Month', 'Temp'])\n\n    # Close the database connection\n    conn.close()\n\n    return result_df\n\nLet’s see an example usage.\n\n# Example output\nquery_climate_database(country = \"India\",\n                       year_begin = 1980,\n                       year_end = 2020,\n                       month = 1)\n\n\n\n\n\n\n\n\nName\nLatitude\nLongitude\nCountry\nYear\nMonth\nTemp\n\n\n\n\n0\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n1\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n2\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n3\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1980\n1\n23.48\n\n\n4\nPBO_ANANTAPUR\n14.583\n77.633\nIndia\n1981\n1\n24.57\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n12603\nDARJEELING\n27.050\n88.270\nIndia\n1995\n1\n5.60\n\n\n12604\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n12605\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n12606\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n12607\nDARJEELING\n27.050\n88.270\nIndia\n1997\n1\n5.70\n\n\n\n\n12608 rows × 7 columns\n\n\n\n\n\nVisualization 1: Geographic Scatter Plot for Yearly Temperature Increases\nBefore moving, let’s first compute a simple estimate of the year-over-year average change in temperature in each month at each station to add more fun. For this, we’ll use our old friend, linear regression. We’ll use the statistical fact that, when regressing Temp against Year, the coefficient of Year will be an estimate of the yearly change in Temp.\n\nfrom sklearn.linear_model import LinearRegression\n\ndef coef(data_group):\n    \"\"\"\n    Calculate the coefficient of the linear regression model for temperature against year.\n\n    This function fits a linear regression model using the \"Year\" as the independent variable\n    and \"Temp\" as the dependent variable. It returns the coefficient of the \"Year\",\n    which represents the rate of change of temperature with respect to the year.\n\n    Parameters:\n    - data_group: A pandas grouped object.\n\n    Returns:\n    - float: The coefficient of the \"Year\" in the linear regression model.\n    \"\"\"\n\n    # Extract x and y variables from data group\n    x = data_group[[\"Year\"]]\n    y = data_group[\"Temp\"]\n\n    # Initialize and fit the linear regression model\n    LR = LinearRegression()\n    LR.fit(x, y)\n\n    # Return the coefficient of the \"Year\"\n    return LR.coef_[0]\n\nNow we are going to write a function called temperature_coefficient_plot to visualize the data we fetched from the database. This function will accept five explicit arguments, and an undetermined number of keyword arguments.\n\ncountry, year_begin, year_end, and month are as in the previous part. min_obs, the minimum required number of years of data for any given station. Only data for stations with at least min_obs years worth of data in the specified month would be plotted; the others would be filtered out. We will use df.transform() plus filtering to achieve this task. **kwargs is an additional keyword arguments passed to px.scatter_mapbox(). These can be used to control the colormap used, the mapbox style, etc.\n\nThe output of this function would be an interactive geographic scatterplot, constructed using Plotly Express, with a point for each station, such that the color of the point reflects an estimate of the yearly change in temperature during the specified month and time period at that station.\n\nfrom plotly import express as px\n\n# Define a color map for the plot\ncolor_map = px.colors.diverging.RdGy_r\n# Create a mapping for creating titles\nmonth_mapping = {\n    1: \"January\",\n    2: \"February\",\n    3: \"March\",\n    4: \"April\",\n    5: \"May\",\n    6: \"June\",\n    7: \"July\",\n    8: \"August\",\n    9: \"September\",\n    10: \"October\",\n    11: \"November\",\n    12: \"December\"\n}\n\ndef temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):\n    \"\"\"\n    Generate a scatter map plot showing the estimated yearly increase in temperature for various stations.\n\n    This function queries temperature data for a specified country, month, and year range.\n    It then calculates the coefficient of the linear regression model for temperature against year\n    for each station and plots the stations on a map. The color of each station represents the\n    estimated yearly increase in temperature.\n\n    Parameters:\n    - country (str): The name of the country for which the plot is to be generated.\n    - year_begin (int): The starting year for the data range.\n    - year_end (int): The ending year for the data range.\n    - month (int): The month for which the plot is to be generated.\n    - min_obs (int): Minimum number of observations required for a station to be included in the plot.\n    - **kwargs: Additional keyword arguments for the plotly express scatter_mapbox function.\n\n    Returns:\n    - plotly.graph_objs._figure.Figure: A Plotly figure object representing the scatter map plot.\n\n    Example:\n    &gt;&gt;&gt; fig = temperature_coefficient_plot(\"India\", 1980, 2020, 1, min_obs=10, zoom=3, center={'lat':23,'lon':80})\n    Generates a scatter map plot for India for the month of January between the years 1980 and 2020.\n    \"\"\"\n\n    # Query the climate database for the specified parameters\n    temp_df = query_climate_database(country, year_begin, year_end, month)\n\n    # Filter stations based on the minimum number of observations\n    temp_df['min_obs'] = temp_df.groupby('Name')['Year'].transform('nunique')\n    temp_df = temp_df[temp_df['min_obs'] &gt;= min_obs]\n\n    # Calculate the coefficient for each station and merge it into the main dataframe\n    coefs = temp_df.groupby([\"Name\"]).apply(coef)\n    coefs = coefs.reset_index()\n    temp_df = pd.merge(temp_df, coefs, on='Name')\n    temp_df.rename(columns={0: 'Estimate'}, inplace=True)\n    temp_df['Estimate'] = temp_df['Estimate'].round(4)  # Round the estimates for better visualization\n    max_abs_estimate = temp_df['Estimate'].abs().max()  # Determine the maximum absolute estimate for color scaling\n\n    # Create the scatter map plot using plotly express\n    fig = px.scatter_mapbox(temp_df,\n                            hover_name=\"Name\",\n                            lat=\"Latitude\",\n                            lon=\"Longitude\",\n                            color='Estimate',\n                            range_color=[-max_abs_estimate, max_abs_estimate],\n                            **kwargs)\n\n    # Update the layout and title of the plot\n    fig.update_layout(title_text=f\"\"\"Estimate of yearly increase in temperature in {month_mapping[month]} for stations in {country}, between {year_begin} to {year_end}\"\"\")\n\n    return fig\n\nLet’s try generating a scatter map plot of temperature for India in January between the years 1980 and 2020.\n\n# Example usage: Generate and display the plot for India\nfig = temperature_coefficient_plot(\"India\", 1980, 2020, 1, min_obs=10,\n                                  zoom=3,\n                                  center={'lat':23,'lon':80},\n                                  mapbox_style=\"carto-positron\",\n                                  color_continuous_scale=color_map)\nfig.show()\n\n\n\n\nFrom this graph we can see that the estimate in temperature increase mostly appears near the border lines of India, while inland temperature is expected to drop.\nTo generalize the fucntion, let’s test with an another example.\n\nfig = temperature_coefficient_plot(\"China\", 1960, 1980, 10, min_obs = 10,\n                                  zoom = 2.5,\n                                  center = {'lat':40,'lon':110},\n                                  mapbox_style=\"carto-positron\",\n                                  color_continuous_scale=color_map)\nfig.show()\n\n\n\n\nThe graphs shows that the stations mostly centered at the South Eastern side of China, while the largest estimate in temperature increase appears in far North and West.\n\n\nVisualization 2: Line Plot for Yearly and Monthly Average Temperature Change\nIn this section, we want to ask: how does the average temperature in certain country changes over time?\nTo answer this question, we may create a line plot where x axis is date and y axis is the average temperature.\n\nAgain, we are going to start with a query function called query_avg_temp_by_country which accepts three arguments: country, year_begin, and year_end as in the previous part.\n\nThe return value is a Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year.\n\ndef query_avg_temp_by_country(country, year_begin=1901, year_end=2020):\n    \"\"\"\n    Fetch average temperature data for a specified country from an SQLite database.\n\n    This function queries temperature data based on a specified country and a year range\n    from an SQLite database and returns the data as a pandas DataFrame.\n\n    Parameters:\n    - country (str): The name of the country for which data is to be fetched.\n    - year_begin (int, optional): The starting year for the data range. Default is 1901.\n    - year_end (int, optional): The ending year for the data range. Default is 2020.\n\n    Returns:\n    - pd.DataFrame: A DataFrame containing temperature data for the specified country and year range.\n\n    Example:\n    &gt;&gt;&gt; df = query_avg_temp_by_country('India', year_begin=2000, year_end=2010)\n    Fetches temperature data for India between the years 2000 and 2010.\n    \"\"\"\n\n    # Connect to the SQLite database\n    conn = sqlite3.connect(\"temps.db\")\n    cursor = conn.cursor()\n\n    # Execute the SQL query to fetch temperature data\n    cursor.execute(f\"SELECT s.Country, t.Year, t.Month, t.Temp \\\n                     FROM temperatures t JOIN stations s ON s.ID = t.ID \\\n                     WHERE s.Country = '{country}' AND t.Year &gt;= {year_begin} AND t.Year &lt;= {year_end}\")\n\n    # Convert the fetched data to a pandas DataFrame\n    result_df = pd.DataFrame(cursor.fetchall(), columns=['Country', 'Year', 'Month', 'Temp'])\n\n    # Close the database connection\n    conn.close()\n\n    return result_df\n\nThen similarly, we will create a user-friendly function called temp_trend_lineplot to help us with the plotting. The function is supposed to takes in country, year_begin, and year_end as in the previous part, and returns a line plot show the monthly and yearly change in average temperature.\nBut beside the baseline, we can have some addition to the interactive plot. We will create two seperate figures for monthly and yearly average temperature, and adds bottons to control the displayed time period.\nIn the actual inplementation, we need to process the data using groupby() to get the average for a specific time period and to_datetime function to convert the time into datetime object for plotting.\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndef temp_trend_lineplot(country, year_begin=1901, year_end=2020):\n    \"\"\"\n    Generate a time series line plot showing the monthly and yearly average temperature for a specified country.\n\n    Parameters:\n    - country (str): The name of the country for which the plot is to be generated.\n    - year_begin (int, optional): The starting year for the data range. Default is 1901.\n    - year_end (int, optional): The ending year for the data range. Default is 2020.\n\n    Returns:\n    - A Plotly figure object representing the time series line plot.\n\n    Example:\n    &gt;&gt;&gt; fig = temp_trend_lineplot('India')\n    Generates a line plot for India showing monthly and yearly average temperatures.\n    \"\"\"\n\n    # Fetch average temperature data for the specified country and year range\n    result_df = query_avg_temp_by_country(country, year_begin, year_end)\n\n    # Calculate monthly average temperatures\n    avgs_df = result_df.groupby(['Year', 'Month'])['Temp'].mean().reset_index()\n    avgs_df['Date'] = pd.to_datetime(avgs_df['Year'].astype(str) + '-' + avgs_df['Month'].astype(str) + '-01')\n\n    # Calculate yearly average temperatures\n    yearly_avg = avgs_df.resample('Y', on='Date').mean()\n\n    # Create subplots for both monthly and yearly averages\n    fig = make_subplots(rows=2, cols=1,\n                        shared_xaxes=True, vertical_spacing=0.1,\n                        subplot_titles=('Monthly Average', 'Yearly Average'))\n\n    # Add trace for monthly average temperatures\n    fig.add_trace(\n        go.Scatter(x=avgs_df.Date, y=avgs_df.Temp, name='Monthly Average'),\n        row=1, col=1)\n\n    # Add trace for yearly average temperatures\n    fig.add_trace(\n        go.Scatter(x=yearly_avg.index, y=yearly_avg.Temp, name='Yearly Average'),\n        row=2, col=1)\n\n    # Set the title and layout properties for the plot\n    fig.update_layout(\n        title_text=f\"Time series average temperature in {country}\",\n        height=800\n    )\n\n    # Add a range slider for date selection\n    fig.update_layout(\n        xaxis=dict(\n            rangeselector=dict(\n                buttons=list([\n                    dict(count=6,\n                         label=\"6m\",\n                         step=\"month\",\n                         stepmode=\"backward\"),\n                    dict(count=1,\n                         label=\"1y\",\n                         step=\"year\",\n                         stepmode=\"backward\"),\n                    dict(count=5,\n                         label=\"5y\",\n                         step=\"year\",\n                         stepmode=\"backward\"),\n                    dict(step=\"all\")\n                ])\n            ),\n            rangeslider=dict(\n                visible=False\n            ),\n            type=\"date\"\n        )\n    )\n    return fig\n\n\n# Example usage: Generate and display the plot for India\nfig = temp_trend_lineplot('India')\nfig.show()\n\n\n\n\nIt seems that the seasonal temperature change are pretty regular in the long term, but in general, the yearly average temperature plot suggests that the temperature in India keeps getting warm from 1901 to recent years, though with some fluctuations.\nSee an another example.\n\nfig = temp_trend_lineplot('United States', year_begin = 2000, year_end = 2020)\nfig.show()\n\n\n\n\nThe seasonal pattern is also clear in the US, but it fluctuates at a much lower level compared with India, from around 0 to 25, while India’s temperature varies from around 16 to 30.\n\n\nVisualization 3: Stacked Histogram With Box Plot for Temperature Distribution\nIn this section, we want to answer the question: how does the distribution of temperature differ between different countries?\nAs usual, the first task is to create a query function to retrieve the data. We will create a function called query_temp_by_country that takes four parameters, one required list-type argument countries, and three optional arguments: month,year_begin, year_end. If month is not specified, then it will return all temperature data within the time period. The return would be a DataFrame containing temperature data for the specified countries, month, and year range.\n\ndef query_temp_by_country(countries, month=0, year_begin=1901, year_end=2020):\n    \"\"\"\n    Fetch temperature data for specified countries from an SQLite database.\n\n    This function queries temperature data based on a list of countries, a specified month,\n    and a year range from the database. The data is returned as a pandas DataFrame.\n\n    Parameters:\n    - countries (list of str): A list of country names for which data is to be fetched.\n    - month (int, optional): The month for which data is to be fetched. Default is 0, which fetches data for all months.\n    - year_begin (int, optional): The starting year for the data range. Default is 1901.\n    - year_end (int, optional): The ending year for the data range. Default is 2020.\n\n    Returns:\n    - pd.DataFrame: A DataFrame containing temperature data for the specified countries, month, and year range.\n\n    Example:\n    &gt;&gt;&gt; query_temp_by_country(['Zimbabwe', 'USA'], month=1, year_begin=2000, year_end=2010)\n    Returns a DataFrame with temperature data for Zimbabwe and USA for the month of January between the years 2000 and 2010.\n    \"\"\"\n\n    conn = sqlite3.connect(\"temps.db\")\n    cursor = conn.cursor()\n\n    # Create a placeholder for each country in the list\n    placeholders = ', '.join(['?'] * len(countries))\n\n    # Using parameterized query for different input length\n    query_str = f\"\"\"SELECT t.Year, t.Temp, s.Country, t.Month\n                    FROM temperatures t JOIN stations s\n                    ON s.ID = t.ID\n                    WHERE s.Country IN ({placeholders}) AND t.Year &gt;= ? AND t.Year &lt;= ?\"\"\"\n\n    # List of parameters for the query\n    params = countries + [year_begin, year_end]\n\n    # Add restrictions to month depending on the input\n    if month &gt; 0:\n        query_str += ' AND t.Month = ?'\n        params.append(month)\n\n    # Query and get results\n    cursor.execute(query_str, params)\n    result_df = pd.DataFrame(cursor.fetchall(), columns=['Year', 'Temp', 'Country', 'Month'])\n    conn.close()\n\n    return result_df\n\nWith the query function, we can start working on the actual plotting function. We will create a function named stacked_histogram that takes in the same arguments as query_temp_by_country. Since the input is a bit different as previous functions, we hope to remind the user of the data type. In Python Raises...TypeError allows us to do this.\nAs return, we hope to get a stacked histogram for a list of countries, with their box plots, where the y axis suggest the number of observations, and x axis specifies temperature bins.\n\ndef stacked_histogram(countries, month=0, year_begin=1901, year_end=2020):\n    \"\"\"\n    Create a stacked histogram of temperature data for specified countries.\n\n    This function fetches temperature data based on a list of countries, a specified month,\n    and a year range using the `query_temp_by_country` function. It then creates a stacked histogram\n    using Plotly Express and returns the figure.\n\n    Parameters:\n    - countries (list of str): A list of country names for which the histogram is to be created.\n    - month (int, optional): The month for which the histogram is to be created. Default is 0, which uses data for all months.\n    - year_begin (int, optional): The starting year for the data range. Default is 1901.\n    - year_end (int, optional): The ending year for the data range. Default is 2020.\n\n    Returns:\n    - A Plotly figure object representing the stacked histogram.\n\n    Example:\n    &gt;&gt;&gt; fig = stacked_histogram(['Zimbabwe', 'United States'], month=1, year_begin=2000, year_end=2010)\n    Creates and returns a stacked histogram for Zimbabwe and USA for the month of January between the years 2000 and 2010.\n    \"\"\"\n    if type(countries) != list:\n        raise TypeError('Countries must be a list.')\n\n    # retrieve data from database\n    result_df = query_temp_by_country(countries, month, year_begin, year_end)\n    # plot a stacked histogram\n    fig = px.histogram(result_df, x=\"Temp\", color=\"Country\", marginal='box')\n    # add a title\n    title_text = f\"Stacked histogram of historical termperature distribution between {year_begin} and {year_end}\"\n    if month&gt;0:\n            title_text += f\" in {month_mapping[month]}\"\n    \n    # Set the title\n    fig.update_layout(\n        title_text=title_text\n    )\n\n    return fig\n\n\n# Let's try an extreme cases.\nstacked_histogram(['Zimbabwe','Netherlands'])\n\n\n\n\nWe can tell that the two countries have different climate patterns since their interquartile range did not overlap. Also, the height of the stacked chart suggest probably these two countries have similar numbers of stations.\n\n# One more example\nstacked_histogram(['Argentina', 'China','Canada'], month = 10)\n\n\n\n\nFrom this graph, we can tell that Canada have many extreme values below 0, as the outliers. China has the longest interquartile range, suggesting a larger variation in climate patterns within the country."
  }
]